<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sensor-DSP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sensor-DSP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__sensor__dsp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sensor-DSP</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The Sensor-DSP library provides signal processing functions required to support the implementation of different sensor applications, i.e. </p>
<p>radar gesture recognition, vital sensing and presence detection.</p>
<p><b>Features:</b></p><ul>
<li>Range and Doppler FFT</li>
<li>FFT windowing related functions</li>
<li>Detection related functions</li>
<li>Angle estimation related functions</li>
</ul>
<p>The Sensor-DSP library builds on top of the standard ARM CMSIS-DSP library. </p><div class="image">
<img src="software-architecture-overview.png" alt="software-architecture-overview.png"/>
</div>
<h1><a class="anchor" id="subsection_sensor_dsp_quickstart"></a>
Quick Start Guide</h1>
<p>The below steps describe the simplest way of adding the Sensor-DSP library into an application.</p>
<ol type="1">
<li>Open/Create an application where to add the Sensor-DSP library.</li>
<li>Add the Sensor-DSP library to your project. Launch ModusToolbox Library Manager and enable the Sensor-DSP library. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure the Sensor-DSP library is included in your project as ModusToolbox dependency.</li>
<li>Include Sensor-DSP in the main.c file: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ifx_sensor_dsp.h&quot;</span></div></div><!-- fragment --></li>
<li>The following code shows a simple example calculating the Doppler FFT on radar data frame: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define NUM_SAMPLES_PER_CHRIP (128)</span></div><div class="line"><span class="preprocessor">#define NUM_CHIRPS_PER_FRAME  (16)</span></div><div class="line"><span class="preprocessor">#define NUM_RANGE_BINS        (NUM_SAMPLES_PER_CHRIP / 2)</span></div><div class="line"><span class="preprocessor">#define NUM_DOPPLER_BINS      (NUM_CHIRPS_PER_FRAME)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> float32_t win_range[NUM_SAMPLES_PER_CHRIP];</div><div class="line"><span class="keyword">static</span> float32_t win_doppler[NUM_CHIRPS_PER_FRAME];</div><div class="line"><span class="keyword">static</span> float32_t frame_array[NUM_SAMPLES_PER_CHRIP * NUM_CHIRPS_PER_FRAME];</div><div class="line"><span class="keyword">static</span> <a class="code" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> range_array[NUM_RANGE_BINS * NUM_SAMPLES_PER_CHRIP];</div><div class="line"><span class="keyword">static</span> <a class="code" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> doppler_array[NUM_DOPPLER_BINS * NUM_RANGE_BINS];</div><div class="line"></div><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: main</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__sensor__dsp.html#ga5ef2b0a94b36ebc737ad84642b7af5c2">ifx_window_blackman_f32</a>(win_range, NUM_SAMPLES_PER_CHRIP);</div><div class="line">    <a class="code" href="group__group__sensor__dsp.html#ga76e047969a994a2effa80a3162cb8bec">ifx_range_fft_f32</a>(frame_array,</div><div class="line">                      range_array,</div><div class="line">                      <span class="keyword">false</span>,</div><div class="line">                      win_range,</div><div class="line">                      NUM_SAMPLES_PER_CHRIP,</div><div class="line">                      NUM_CHIRPS_PER_FRAME);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__sensor__dsp.html#ga94a7c96926ba1687781154e98eccef61">ifx_window_blackmanharris_f32</a>(win_doppler, NUM_DOPPLER_BINS);</div><div class="line">    <a class="code" href="group__group__sensor__dsp.html#ga699e9e53ca37cc3cef48b4b48cb27325">ifx_doppler_cfft_f32</a>(range_array,</div><div class="line">                         doppler_array,</div><div class="line">                         <span class="keyword">true</span>,</div><div class="line">                         win_doppler,</div><div class="line">                         NUM_RANGE_BINS,</div><div class="line">                         NUM_CHIRPS_PER_FRAME);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__sensor__dsp.html#gac743c4d5699e713d227bc728a2e01f89">ifx_shift_cfft_f32</a>(doppler_array, NUM_DOPPLER_BINS, NUM_RANGE_BINS);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --></li>
</ol>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structifx__mti__inst__f32"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#structifx__mti__inst__f32">ifx_mti_inst_f32</a></td></tr>
<tr class="memdesc:structifx__mti__inst__f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance structure for the MTI calculation.  <a href="group__group__sensor__dsp.html#structifx__mti__inst__f32">More...</a><br /></td></tr>
<tr class="separator:structifx__mti__inst__f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structifx__peak__search__opts__f32__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#structifx__peak__search__opts__f32__t">ifx_peak_search_opts_f32_t</a></td></tr>
<tr class="memdesc:structifx__peak__search__opts__f32__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peak search options.  <a href="group__group__sensor__dsp.html#structifx__peak__search__opts__f32__t">More...</a><br /></td></tr>
<tr class="separator:structifx__peak__search__opts__f32__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaebdd0124e544e182c012df229bd4d945"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gaebdd0124e544e182c012df229bd4d945">IFX_SENSOR_DSP_STATUS_OK</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaebdd0124e544e182c012df229bd4d945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result code indicating successful operation.  <a href="#gaebdd0124e544e182c012df229bd4d945">More...</a><br /></td></tr>
<tr class="separator:gaebdd0124e544e182c012df229bd4d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617730128d14f830c8a48b285c7bca0b"><td class="memItemLeft" align="right" valign="top"><a id="ga617730128d14f830c8a48b285c7bca0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga617730128d14f830c8a48b285c7bca0b">IFX_SENSOR_DSP_ARGUMENT_ERROR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga617730128d14f830c8a48b285c7bca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result code indicating a not supported argument value. <br /></td></tr>
<tr class="separator:ga617730128d14f830c8a48b285c7bca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad360a84f106673ea556e3867dad90876"><td class="memItemLeft" align="right" valign="top"><a id="gad360a84f106673ea556e3867dad90876"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gad360a84f106673ea556e3867dad90876">IFX_LIGHT_SPEED_M_S</a>&#160;&#160;&#160;(299792458.0F)</td></tr>
<tr class="memdesc:gad360a84f106673ea556e3867dad90876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The speed of light in vacuum, in meters per second. <br /></td></tr>
<tr class="separator:gad360a84f106673ea556e3867dad90876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5e5f049794c9d896a2788af15928d8"><td class="memItemLeft" align="right" valign="top"><a id="gaac5e5f049794c9d896a2788af15928d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gaac5e5f049794c9d896a2788af15928d8">IFX_SENSOR_DSP_VERSION_MAJOR</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaac5e5f049794c9d896a2788af15928d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SensorDSP major version. <br /></td></tr>
<tr class="separator:gaac5e5f049794c9d896a2788af15928d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bba792c4a41c87946a8d9338958aa90"><td class="memItemLeft" align="right" valign="top"><a id="ga0bba792c4a41c87946a8d9338958aa90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga0bba792c4a41c87946a8d9338958aa90">IFX_SENSOR_DSP_VERSION_MINOR</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:ga0bba792c4a41c87946a8d9338958aa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">SensorDSP minor version. <br /></td></tr>
<tr class="separator:ga0bba792c4a41c87946a8d9338958aa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b2efd111e379f1915a5604b843026c"><td class="memItemLeft" align="right" valign="top"><a id="ga54b2efd111e379f1915a5604b843026c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga54b2efd111e379f1915a5604b843026c">IFX_SENSOR_DSP_VERSION_REVERSION</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga54b2efd111e379f1915a5604b843026c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SensorDSP version. <br /></td></tr>
<tr class="separator:ga54b2efd111e379f1915a5604b843026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a42fd93c01356e379b4d5dddf4b7c51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga6a42fd93c01356e379b4d5dddf4b7c51">POS_INF_F32</a>&#160;&#160;&#160;(1.0F/0.0F)</td></tr>
<tr class="memdesc:ga6a42fd93c01356e379b4d5dddf4b7c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <a href="#ga6a42fd93c01356e379b4d5dddf4b7c51">More...</a><br /></td></tr>
<tr class="separator:ga6a42fd93c01356e379b4d5dddf4b7c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9b11128b2635104e9eb5b8d07fc976"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga5c9b11128b2635104e9eb5b8d07fc976">NEG_INF_F32</a>&#160;&#160;&#160;(-1.0F/0.0F)</td></tr>
<tr class="memdesc:ga5c9b11128b2635104e9eb5b8d07fc976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <a href="#ga5c9b11128b2635104e9eb5b8d07fc976">More...</a><br /></td></tr>
<tr class="separator:ga5c9b11128b2635104e9eb5b8d07fc976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e5924a95fe3976c677f69067f06fa6"><td class="memItemLeft" align="right" valign="top"><a id="ga30e5924a95fe3976c677f69067f06fa6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga30e5924a95fe3976c677f69067f06fa6">PI_2_F32</a>&#160;&#160;&#160;(1.570796370506F)</td></tr>
<tr class="memdesc:ga30e5924a95fe3976c677f69067f06fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI/2. <br /></td></tr>
<tr class="separator:ga30e5924a95fe3976c677f69067f06fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282c747d9be788e2f626388f373980d4"><td class="memItemLeft" align="right" valign="top"><a id="ga282c747d9be788e2f626388f373980d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga282c747d9be788e2f626388f373980d4">PI_4_F32</a>&#160;&#160;&#160;(0.78539816339F)</td></tr>
<tr class="memdesc:ga282c747d9be788e2f626388f373980d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI/4. <br /></td></tr>
<tr class="separator:ga282c747d9be788e2f626388f373980d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97bbbc83ed980f04d3c8200ca6231161"><td class="memItemLeft" align="right" valign="top"><a id="ga97bbbc83ed980f04d3c8200ca6231161"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga97bbbc83ed980f04d3c8200ca6231161">CREAL_F32</a>(x)&#160;&#160;&#160;(((float32_t *)       &amp;(x))[0])</td></tr>
<tr class="memdesc:ga97bbbc83ed980f04d3c8200ca6231161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to assign real part of a complex floating number. <br /></td></tr>
<tr class="separator:ga97bbbc83ed980f04d3c8200ca6231161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fd3a9e0102dc7815bf50a96a613e61"><td class="memItemLeft" align="right" valign="top"><a id="ga72fd3a9e0102dc7815bf50a96a613e61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga72fd3a9e0102dc7815bf50a96a613e61">CIMAG_F32</a>(x)&#160;&#160;&#160;(((float32_t *)       &amp;(x))[1])</td></tr>
<tr class="memdesc:ga72fd3a9e0102dc7815bf50a96a613e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to assign imaginary part of a complex floating number. <br /></td></tr>
<tr class="separator:ga72fd3a9e0102dc7815bf50a96a613e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8af72be35b8acbc9096afae448302b44"><td class="memItemLeft" align="right" valign="top"><a id="ga8af72be35b8acbc9096afae448302b44"></a>
typedef _Complex float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a></td></tr>
<tr class="memdesc:ga8af72be35b8acbc9096afae448302b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex float number type. <br /></td></tr>
<tr class="separator:ga8af72be35b8acbc9096afae448302b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab87601559c2a0fbb5b3b25c8b8198708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gab87601559c2a0fbb5b3b25c8b8198708">ifx_mean_removal_f32</a> (float32_t *v, uint32_t len)</td></tr>
<tr class="memdesc:gab87601559c2a0fbb5b3b25c8b8198708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts the calculated array mean from each element of the floating point array.  <a href="#gab87601559c2a0fbb5b3b25c8b8198708">More...</a><br /></td></tr>
<tr class="separator:gab87601559c2a0fbb5b3b25c8b8198708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812928d85219be3e8a0fb5e1f2c733fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga812928d85219be3e8a0fb5e1f2c733fc">ifx_cmplx_mean_removal_f32</a> (<a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *v, uint32_t len)</td></tr>
<tr class="memdesc:ga812928d85219be3e8a0fb5e1f2c733fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts the calculated array mean from each element of the complex floating point array.  <a href="#ga812928d85219be3e8a0fb5e1f2c733fc">More...</a><br /></td></tr>
<tr class="separator:ga812928d85219be3e8a0fb5e1f2c733fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e047969a994a2effa80a3162cb8bec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga76e047969a994a2effa80a3162cb8bec">ifx_range_fft_f32</a> (float32_t *frame, <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *range, bool mean_removal, const float32_t *win, uint16_t num_samples_per_chirp, uint16_t num_chirps_per_frame)</td></tr>
<tr class="memdesc:ga76e047969a994a2effa80a3162cb8bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate range FFT from real floating point raw radar data.  <a href="#ga76e047969a994a2effa80a3162cb8bec">More...</a><br /></td></tr>
<tr class="separator:ga76e047969a994a2effa80a3162cb8bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e7a796db197ea125edbec98e1a17e9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga89e7a796db197ea125edbec98e1a17e9">ifx_range_cfft_f32</a> (<a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *frame, bool mean_removal, const float32_t *win, uint16_t num_samples_per_chirp, uint16_t num_chirps_per_frame)</td></tr>
<tr class="memdesc:ga89e7a796db197ea125edbec98e1a17e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate range FFT from complex floating point raw radar data.  <a href="#ga89e7a796db197ea125edbec98e1a17e9">More...</a><br /></td></tr>
<tr class="separator:ga89e7a796db197ea125edbec98e1a17e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699e9e53ca37cc3cef48b4b48cb27325"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga699e9e53ca37cc3cef48b4b48cb27325">ifx_doppler_cfft_f32</a> (<a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *range, <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *doppler, bool mean_removal, const float32_t *win, uint16_t num_range_bins, uint16_t num_chirps_per_frame)</td></tr>
<tr class="memdesc:ga699e9e53ca37cc3cef48b4b48cb27325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate doppler FFT from range data.  <a href="#ga699e9e53ca37cc3cef48b4b48cb27325">More...</a><br /></td></tr>
<tr class="separator:ga699e9e53ca37cc3cef48b4b48cb27325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef2b0a94b36ebc737ad84642b7af5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga5ef2b0a94b36ebc737ad84642b7af5c2">ifx_window_blackman_f32</a> (float32_t *win, uint32_t len)</td></tr>
<tr class="memdesc:ga5ef2b0a94b36ebc737ad84642b7af5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a symmetric Blackman window.  <a href="#ga5ef2b0a94b36ebc737ad84642b7af5c2">More...</a><br /></td></tr>
<tr class="separator:ga5ef2b0a94b36ebc737ad84642b7af5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a7c96926ba1687781154e98eccef61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga94a7c96926ba1687781154e98eccef61">ifx_window_blackmanharris_f32</a> (float32_t *win, uint32_t len)</td></tr>
<tr class="memdesc:ga94a7c96926ba1687781154e98eccef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a symmetric four-term Blackman-Harris window.  <a href="#ga94a7c96926ba1687781154e98eccef61">More...</a><br /></td></tr>
<tr class="separator:ga94a7c96926ba1687781154e98eccef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6146a41bd81faad6209e05eefaaa5423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga6146a41bd81faad6209e05eefaaa5423">ifx_window_hamming_f32</a> (float32_t *win, uint32_t len)</td></tr>
<tr class="memdesc:ga6146a41bd81faad6209e05eefaaa5423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a symmetric Hamming window.  <a href="#ga6146a41bd81faad6209e05eefaaa5423">More...</a><br /></td></tr>
<tr class="separator:ga6146a41bd81faad6209e05eefaaa5423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae824dbd443ec51f3803c89f03b04683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gaae824dbd443ec51f3803c89f03b04683">ifx_window_hann_f32</a> (float32_t *win, uint32_t len)</td></tr>
<tr class="memdesc:gaae824dbd443ec51f3803c89f03b04683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a symmetric Hann window.  <a href="#gaae824dbd443ec51f3803c89f03b04683">More...</a><br /></td></tr>
<tr class="separator:gaae824dbd443ec51f3803c89f03b04683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f930816830663a22daae70712f3446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga69f930816830663a22daae70712f3446">ifx_gen_steering_matrix_f32</a> (float32_t ang_est_range, uint32_t num_angles, float32_t antenna_spacing_mm, float32_t lambda_mm, uint32_t num_ant, const arm_matrix_instance_f32 *pDst)</td></tr>
<tr class="memdesc:ga69f930816830663a22daae70712f3446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a steering vector for AOA estimation given the theta range, number of beams, and number of antennas Defines a method for generating steering vector data input The generated steering vector will span from -angEstRange to angEstRange with increments of ang_est_resolution The generated steering vector is already transposed and can be used directly for all further AOA estimations (bartlett/capon)  <a href="#ga69f930816830663a22daae70712f3446">More...</a><br /></td></tr>
<tr class="separator:ga69f930816830663a22daae70712f3446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8228714ad86e28e2dbd09634d872ae0b"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga8228714ad86e28e2dbd09634d872ae0b">ifx_angle_dbf_f32</a> (const arm_matrix_instance_f32 *pInput, const arm_matrix_instance_f32 *pSteering, arm_matrix_instance_f32 *pOutput)</td></tr>
<tr class="memdesc:ga8228714ad86e28e2dbd09634d872ae0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a phase shift beam forming matrix Defines a method for generating a phase shift beam forming matrix by multiplying the steering matrix by the input.  <a href="#ga8228714ad86e28e2dbd09634d872ae0b">More...</a><br /></td></tr>
<tr class="separator:ga8228714ad86e28e2dbd09634d872ae0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac743c4d5699e713d227bc728a2e01f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gac743c4d5699e713d227bc728a2e01f89">ifx_shift_cfft_f32</a> (<a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *v, uint32_t len, uint32_t dim)</td></tr>
<tr class="memdesc:gac743c4d5699e713d227bc728a2e01f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the array of complex numbers.  <a href="#gac743c4d5699e713d227bc728a2e01f89">More...</a><br /></td></tr>
<tr class="separator:gac743c4d5699e713d227bc728a2e01f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7927e93e733dc185059a58c695444aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gad7927e93e733dc185059a58c695444aa">ifx_mti_init_f32</a> (<a class="el" href="group__group__sensor__dsp.html#structifx__mti__inst__f32">ifx_mti_inst_f32</a> *inst, float32_t alpha, uint32_t len, float32_t *historical_data)</td></tr>
<tr class="memdesc:gad7927e93e733dc185059a58c695444aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes MTI control structure.  <a href="#gad7927e93e733dc185059a58c695444aa">More...</a><br /></td></tr>
<tr class="separator:gad7927e93e733dc185059a58c695444aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3677b63229a5255d90140048b0edde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gacf3677b63229a5255d90140048b0edde">ifx_mti_f32</a> (const <a class="el" href="group__group__sensor__dsp.html#structifx__mti__inst__f32">ifx_mti_inst_f32</a> *inst, const float32_t *in_data, float32_t *out_data)</td></tr>
<tr class="memdesc:gacf3677b63229a5255d90140048b0edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">(M)oving (T)arget (I)ndication  <a href="#gacf3677b63229a5255d90140048b0edde">More...</a><br /></td></tr>
<tr class="separator:gacf3677b63229a5255d90140048b0edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96c1f1ceab6c06d3b6c5d460bd0e791"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gab96c1f1ceab6c06d3b6c5d460bd0e791">ifx_peak_search_f32</a> (const float32_t *x, int32_t length, int32_t *peak_indices, int32_t max_peaks, const <a class="el" href="group__group__sensor__dsp.html#structifx__peak__search__opts__f32__t">ifx_peak_search_opts_f32_t</a> *opts)</td></tr>
<tr class="memdesc:gab96c1f1ceab6c06d3b6c5d460bd0e791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find peaks in array.  <a href="#gab96c1f1ceab6c06d3b6c5d460bd0e791">More...</a><br /></td></tr>
<tr class="separator:gab96c1f1ceab6c06d3b6c5d460bd0e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05782d3800ac91410af581c86de274ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga05782d3800ac91410af581c86de274ea">ifx_flip_f32</a> (float32_t *v, uint32_t len)</td></tr>
<tr class="memdesc:ga05782d3800ac91410af581c86de274ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the array of float numbers.  <a href="#ga05782d3800ac91410af581c86de274ea">More...</a><br /></td></tr>
<tr class="separator:ga05782d3800ac91410af581c86de274ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973673fc0693751f4b82afa18df97c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga973673fc0693751f4b82afa18df97c12">ifx_rotate_f32</a> (float32_t *v, uint32_t len, uint32_t k)</td></tr>
<tr class="memdesc:ga973673fc0693751f4b82afa18df97c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the array of float numbers.  <a href="#ga973673fc0693751f4b82afa18df97c12">More...</a><br /></td></tr>
<tr class="separator:ga973673fc0693751f4b82afa18df97c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ff27583971a85ec04a57702b81e6e1"><td class="memItemLeft" align="right" valign="top">static float32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gaf6ff27583971a85ec04a57702b81e6e1">ifx_range_resolution</a> (float32_t bandwidth_hz)</td></tr>
<tr class="memdesc:gaf6ff27583971a85ec04a57702b81e6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate range resolution.  <a href="#gaf6ff27583971a85ec04a57702b81e6e1">More...</a><br /></td></tr>
<tr class="separator:gaf6ff27583971a85ec04a57702b81e6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b6faae2c5b3c4fc20dd0a6f0b80d8c"><td class="memItemLeft" align="right" valign="top">static float32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga28b6faae2c5b3c4fc20dd0a6f0b80d8c">ifx_range_resolution_ex</a> (uint32_t num_samples, float32_t sample_rate_hz, float32_t freq_slope_hz_s)</td></tr>
<tr class="memdesc:ga28b6faae2c5b3c4fc20dd0a6f0b80d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate range resolution including number of samples, sample rate and frequency slope.  <a href="#ga28b6faae2c5b3c4fc20dd0a6f0b80d8c">More...</a><br /></td></tr>
<tr class="separator:ga28b6faae2c5b3c4fc20dd0a6f0b80d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb68635375f25ca2961b454c9914d35"><td class="memItemLeft" align="right" valign="top">static float32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga0eb68635375f25ca2961b454c9914d35">ifx_max_range</a> (uint32_t sample_rate_hz, float32_t freq_slope_hz_s)</td></tr>
<tr class="memdesc:ga0eb68635375f25ca2961b454c9914d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating max range.  <a href="#ga0eb68635375f25ca2961b454c9914d35">More...</a><br /></td></tr>
<tr class="separator:ga0eb68635375f25ca2961b454c9914d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804edab930fd07601db57fe99cb8f013"><td class="memItemLeft" align="right" valign="top">static float32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga804edab930fd07601db57fe99cb8f013">ifx_doppler_resolution</a> (float32_t bandwidth_hz, float32_t frame_time_s)</td></tr>
<tr class="memdesc:ga804edab930fd07601db57fe99cb8f013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating Doppler resolution.  <a href="#ga804edab930fd07601db57fe99cb8f013">More...</a><br /></td></tr>
<tr class="separator:ga804edab930fd07601db57fe99cb8f013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad507aa90ef143738733d5cddd2cc907a"><td class="memItemLeft" align="right" valign="top">static float32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gad507aa90ef143738733d5cddd2cc907a">ifx_max_doppler</a> (float32_t bandwidth_hz, float32_t chirp_time_s)</td></tr>
<tr class="memdesc:gad507aa90ef143738733d5cddd2cc907a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating Max Doppler.  <a href="#gad507aa90ef143738733d5cddd2cc907a">More...</a><br /></td></tr>
<tr class="separator:gad507aa90ef143738733d5cddd2cc907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d027a0c1558b06e5e7794a9b3b95055"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#ga0d027a0c1558b06e5e7794a9b3b95055">ifx_arcsin_f32</a> (float32_t x, float32_t *result)</td></tr>
<tr class="memdesc:ga0d027a0c1558b06e5e7794a9b3b95055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns arcus sinus of the given input, in radians.  <a href="#ga0d027a0c1558b06e5e7794a9b3b95055">More...</a><br /></td></tr>
<tr class="separator:ga0d027a0c1558b06e5e7794a9b3b95055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa31f1c6bc68fe4b337e655072ca813c"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sensor__dsp.html#gaaa31f1c6bc68fe4b337e655072ca813c">ifx_angle_monopulse_f32</a> (const <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *rx1, const <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *rx2, uint32_t size, float32_t wavelength, float32_t antenna_spacing, float32_t *angle)</td></tr>
<tr class="memdesc:gaaa31f1c6bc68fe4b337e655072ca813c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle of the direction of arrival of a monopulse Defines a method for calculating the angle of monopulse with given wavelength, spacing between two antennas and phase shifts.  <a href="#gaaa31f1c6bc68fe4b337e655072ca813c">More...</a><br /></td></tr>
<tr class="separator:gaaa31f1c6bc68fe4b337e655072ca813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structifx__mti__inst__f32" id="structifx__mti__inst__f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structifx__mti__inst__f32">&#9670;&nbsp;</a></span>ifx_mti_inst_f32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ifx_mti_inst_f32</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6263f5bc513339c8758d5c996326f32d"></a>uint32_t</td>
<td class="fieldname">
len</td>
<td class="fielddoc">
Size of in_data, out_data, historical_data. </td></tr>
<tr><td class="fieldtype">
<a id="a5826e37f9886eaec8e5623cbdbd1e342"></a>float32_t</td>
<td class="fieldname">
alpha</td>
<td class="fielddoc">
Exponential moving average parameter (0 highest historical influence, 1 lowest) </td></tr>
<tr><td class="fieldtype">
<a id="a2bf4418808c59851217054100dd3b87f"></a>float32_t *</td>
<td class="fieldname">
historical_data</td>
<td class="fielddoc">
Pointer to historical data (size must be equal to len). <p>Initiate with first data or zeros </p>
</td></tr>
</table>

</div>
</div>
<a name="structifx__peak__search__opts__f32__t" id="structifx__peak__search__opts__f32__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structifx__peak__search__opts__f32__t">&#9670;&nbsp;</a></span>ifx_peak_search_opts_f32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ifx_peak_search_opts_f32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a655a24d359f9a7219d02b037524b9a37"></a>float32_t</td>
<td class="fieldname">
height</td>
<td class="fielddoc">
Required height of peaks. </td></tr>
<tr><td class="fieldtype">
<a id="ad0bfb1d7448d079431e40611d6edfbf5"></a>float32_t</td>
<td class="fieldname">
threshold</td>
<td class="fielddoc">
Required threshold of peaks, the vertical distance to its neighboring samples. </td></tr>
<tr><td class="fieldtype">
<a id="af632c38c0bd8ec8ef3fc88e4fef8b1f3"></a>int32_t</td>
<td class="fieldname">
distance</td>
<td class="fielddoc">
Required minimal horizontal distance (&gt;= 1) in samples between neighbouring peaks. </td></tr>
<tr><td class="fieldtype">
<a id="ae86a2eabb58dede5f204c55061fe5bf0"></a>int32_t</td>
<td class="fieldname">
width</td>
<td class="fielddoc">
Required width of peaks in samples. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaebdd0124e544e182c012df229bd4d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebdd0124e544e182c012df229bd4d945">&#9670;&nbsp;</a></span>IFX_SENSOR_DSP_STATUS_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IFX_SENSOR_DSP_STATUS_OK&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result code indicating successful operation. </p>

</div>
</div>
<a id="ga6a42fd93c01356e379b4d5dddf4b7c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a42fd93c01356e379b4d5dddf4b7c51">&#9670;&nbsp;</a></span>POS_INF_F32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POS_INF_F32&#160;&#160;&#160;(1.0F/0.0F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Positive infinity. </p>

</div>
</div>
<a id="ga5c9b11128b2635104e9eb5b8d07fc976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c9b11128b2635104e9eb5b8d07fc976">&#9670;&nbsp;</a></span>NEG_INF_F32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEG_INF_F32&#160;&#160;&#160;(-1.0F/0.0F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negative infinity. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab87601559c2a0fbb5b3b25c8b8198708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab87601559c2a0fbb5b3b25c8b8198708">&#9670;&nbsp;</a></span>ifx_mean_removal_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_mean_removal_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substracts the calculated array mean from each element of the floating point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga812928d85219be3e8a0fb5e1f2c733fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga812928d85219be3e8a0fb5e1f2c733fc">&#9670;&nbsp;</a></span>ifx_cmplx_mean_removal_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_cmplx_mean_removal_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substracts the calculated array mean from each element of the complex floating point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga76e047969a994a2effa80a3162cb8bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e047969a994a2effa80a3162cb8bec">&#9670;&nbsp;</a></span>ifx_range_fft_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ifx_range_fft_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mean_removal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples_per_chirp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_chirps_per_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate range FFT from real floating point raw radar data. </p>
<p>Perform optional mean removal and windowing on the raw radar data prior to 1D FFT. The caller must allocate the memory for the frame and range arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frame</td><td>Pointer to raw radar real data of shape [num_chirps_per_frame][num_adc_samples] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>frame is modified by this function if mean_removal is true and/or win != NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">range</td><td>Pointer to transformed range complex data of shape [num_chirps_per_frame][num_adc_samples/2] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean_removal</td><td>If true, remove mean along samples before 1D FFT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>Window to be applied to the raw radar data prior 1D FFT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be NULL if not windowing is desired </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples_per_chirp</td><td>Number of samples per radar chirp </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_chirps_per_frame</td><td>Number of chirps per radar frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- <a class="el" href="group__group__sensor__dsp.html#gaebdd0124e544e182c012df229bd4d945">IFX_SENSOR_DSP_STATUS_OK</a> : Operation successful<ul>
<li><a class="el" href="group__group__sensor__dsp.html#ga617730128d14f830c8a48b285c7bca0b">IFX_SENSOR_DSP_ARGUMENT_ERROR</a> : Not supported FFT length (num_samples_per_chirp) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga89e7a796db197ea125edbec98e1a17e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89e7a796db197ea125edbec98e1a17e9">&#9670;&nbsp;</a></span>ifx_range_cfft_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ifx_range_cfft_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mean_removal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples_per_chirp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_chirps_per_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate range FFT from complex floating point raw radar data. </p>
<p>Perform optional mean removal and windowing on the ADC data prior to 1D FFT The caller must allocate the memory for the frame and range arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frame</td><td>Pointer to raw radar complex data of shape [num_chirps_per_frame][num_adc_samples] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Processing by this function occurs in-place. The raw radar complex data is replaced by the calculated range FFT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mean_removal</td><td>If true, remove mean along samples before 1D FFT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>Pointer to window to be applied to the raw radar data prior 1D FFT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be NULL if not windowing is desired </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples_per_chirp</td><td>Number of samples per radar chirp </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_chirps_per_frame</td><td>Number of chirps per radar frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- <a class="el" href="group__group__sensor__dsp.html#gaebdd0124e544e182c012df229bd4d945">IFX_SENSOR_DSP_STATUS_OK</a> : Operation successful<ul>
<li><a class="el" href="group__group__sensor__dsp.html#ga617730128d14f830c8a48b285c7bca0b">IFX_SENSOR_DSP_ARGUMENT_ERROR</a> : Not supported FFT length (num_samples_per_chirp) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga699e9e53ca37cc3cef48b4b48cb27325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699e9e53ca37cc3cef48b4b48cb27325">&#9670;&nbsp;</a></span>ifx_doppler_cfft_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ifx_doppler_cfft_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>doppler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mean_removal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_range_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_chirps_per_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate doppler FFT from range data. </p>
<p>Perform optional mean removal and windowing on the range data prior to 1D FFT. The caller must allocate the memory for the range and doppler arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>Pointer to range complex data of shape [num_chirps_per_frame][num_range_bins] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">doppler</td><td>Pointer to transformed range doppler complex data of shape [num_range_bins][num_doppler_bins] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean_removal</td><td>If true, remove mean along samples before 1D FFT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>Pointer to window to be applied to the range data prior 1D FFT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be NULL if not windowing is desired </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_range_bins</td><td>Number of range bins per chirp </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_chirps_per_frame</td><td>Number of chirps per radar frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- <a class="el" href="group__group__sensor__dsp.html#gaebdd0124e544e182c012df229bd4d945">IFX_SENSOR_DSP_STATUS_OK</a> : Operation successful<ul>
<li><a class="el" href="group__group__sensor__dsp.html#ga617730128d14f830c8a48b285c7bca0b">IFX_SENSOR_DSP_ARGUMENT_ERROR</a> : Not supported FFT length (num_chirps_per_frame) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5ef2b0a94b36ebc737ad84642b7af5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ef2b0a94b36ebc737ad84642b7af5c2">&#9670;&nbsp;</a></span>ifx_window_blackman_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_window_blackman_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a symmetric Blackman window. </p>
<p>The function generates a symmetric Blackman window <img class="formulaInl" alt="$w$" src="form_0.png"/> of length <img class="formulaInl" alt="$N$" src="form_1.png"/> using the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_n = \mathrm{0.42} - 0.5 \cos\left( \frac{2\pi n}{N-1} \right) + 0.08 \cos\left( \frac{4\pi n}{N-1} \right),\qquad \mathrm{0} \le\ n &lt; \mathrm{N} \]" src="form_2.png"/>
</p>
<p> The values are populated in the output array 'window' whose pointer is passed as a parameter. The caller is responsible to allocate memory for output. For a window of length <img class="formulaInl" alt="$ N $" src="form_3.png"/> a memory of <img class="formulaInl" alt="$ N*sizeof(float32_t) $" src="form_4.png"/> should be allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">win</td><td>Starting pointer to float32_t array to be populated with output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of window to be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga94a7c96926ba1687781154e98eccef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a7c96926ba1687781154e98eccef61">&#9670;&nbsp;</a></span>ifx_window_blackmanharris_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_window_blackmanharris_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a symmetric four-term Blackman-Harris window. </p>
<p>The function generates a symmetric four-term Blackman-Harris window <img class="formulaInl" alt="$w$" src="form_0.png"/> of length <img class="formulaInl" alt="$N$" src="form_1.png"/> using the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_n = \mathrm{a_0} - \mathrm{a_1} \cos\left( \frac{2\pi n}{N-1} \right) + \mathrm{a_2} \cos\left( \frac{4\pi n}{N-1} \right) - \mathrm{a_3} \cos\left( \frac{6\pi n}{N-1} \right),\qquad \mathrm{0} \le\ n &lt; \mathrm{N} \]" src="form_5.png"/>
</p>
<p>where the coefficient values are </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Coefficient  </th><th class="markdownTableHeadNone">Value -----&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><img class="formulaInl" alt="$\mathrm{a}_0$" src="form_6.png"/>  </td><td class="markdownTableBodyNone">0.35875   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><img class="formulaInl" alt="$\mathrm{a}_1$" src="form_7.png"/>  </td><td class="markdownTableBodyNone">0.48829   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><img class="formulaInl" alt="$\mathrm{a}_2$" src="form_8.png"/>  </td><td class="markdownTableBodyNone">0.14128   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><img class="formulaInl" alt="$\mathrm{a}_3$" src="form_9.png"/>  </td><td class="markdownTableBodyNone">0.01168   </td></tr>
</table>
<p>The window values are populated in the output array 'window' whose pointer is passed as a parameter. The caller is responsible to allocate memory for output. For a window of length <img class="formulaInl" alt="$ N $" src="form_3.png"/> a memory of <img class="formulaInl" alt="$ N*sizeof(float32_t) $" src="form_4.png"/> should be allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">win</td><td>Starting pointer to float32_t array to be populated with output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of window to be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6146a41bd81faad6209e05eefaaa5423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6146a41bd81faad6209e05eefaaa5423">&#9670;&nbsp;</a></span>ifx_window_hamming_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_window_hamming_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a symmetric Hamming window. </p>
<p>The function generates a symmetric Hamming window <img class="formulaInl" alt="$w$" src="form_0.png"/> of length <img class="formulaInl" alt="$N$" src="form_1.png"/> using the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_n = \mathrm{0.54} - \mathrm{0.46} \cos\left( \frac{2\pi n}{N-1}\right), \qquad \mathrm{0} \le\ n &lt; \mathrm{N} \]" src="form_10.png"/>
</p>
<p>The values are populated in the output array 'window' whose pointer is passed as a parameter. The caller is responsible to allocate memory for output. For a window of length <img class="formulaInl" alt="$ N $" src="form_3.png"/> a memory of <img class="formulaInl" alt="$ N*sizeof(float32_t) $" src="form_4.png"/> should be allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">win</td><td>Starting pointer to float32_t array to be populated with output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of window to be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaae824dbd443ec51f3803c89f03b04683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae824dbd443ec51f3803c89f03b04683">&#9670;&nbsp;</a></span>ifx_window_hann_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_window_hann_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a symmetric Hann window. </p>
<p>The function generates a symmetric Hann window <img class="formulaInl" alt="$w$" src="form_0.png"/> of length <img class="formulaInl" alt="$N$" src="form_1.png"/> using the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_n = \mathrm{0.5} \left(\mathrm{1} - \cos\left( \frac{2\pi n}{N-1} \right)\right),\qquad \mathrm{0} \le\ n &lt; \mathrm{N} \]" src="form_11.png"/>
</p>
<p> The values are populated in the output array 'window' whose pointer is passed as a parameter. The caller is responsible to allocate memory for output. For a window of length <img class="formulaInl" alt="$ N $" src="form_3.png"/> a memory of <img class="formulaInl" alt="$ N*sizeof(float32_t) $" src="form_4.png"/> should be allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">win</td><td>Starting pointer to float32_t array to be populated with output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of window to be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga69f930816830663a22daae70712f3446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f930816830663a22daae70712f3446">&#9670;&nbsp;</a></span>ifx_gen_steering_matrix_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_gen_steering_matrix_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>ang_est_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_angles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>antenna_spacing_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>lambda_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arm_matrix_instance_f32 *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a steering vector for AOA estimation given the theta range, number of beams, and number of antennas Defines a method for generating steering vector data input The generated steering vector will span from -angEstRange to angEstRange with increments of ang_est_resolution The generated steering vector is already transposed and can be used directly for all further AOA estimations (bartlett/capon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ang_est_range</td><td>Single side angle of view in radians. zero is directly perpendicular to antenna plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_angles</td><td>Number of beams </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">antenna_spacing_mm</td><td>Radar antenna spacing in mm </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_mm</td><td>Wavelength corresponding to Radar operating frequency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_ant</td><td>The number of receiving antennas </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pDst</td><td>Pointer to output steering matrix array allocated by the user [ rows, columns ] = [ num_angles, num_antennas ] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga8228714ad86e28e2dbd09634d872ae0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8228714ad86e28e2dbd09634d872ae0b">&#9670;&nbsp;</a></span>ifx_angle_dbf_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status ifx_angle_dbf_f32 </td>
          <td>(</td>
          <td class="paramtype">const arm_matrix_instance_f32 *&#160;</td>
          <td class="paramname"><em>pInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arm_matrix_instance_f32 *&#160;</td>
          <td class="paramname"><em>pSteering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arm_matrix_instance_f32 *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a phase shift beam forming matrix Defines a method for generating a phase shift beam forming matrix by multiplying the steering matrix by the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pInput</td><td>Pointer to input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSteering</td><td>Pointer to steering matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOutput</td><td>Pointer to beamforming matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status flag </dd></dl>

</div>
</div>
<a id="gac743c4d5699e713d227bc728a2e01f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac743c4d5699e713d227bc728a2e01f89">&#9670;&nbsp;</a></span>ifx_shift_cfft_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_shift_cfft_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the array of complex numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>Pointer to input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of matrix dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad7927e93e733dc185059a58c695444aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7927e93e733dc185059a58c695444aa">&#9670;&nbsp;</a></span>ifx_mti_init_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_mti_init_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sensor__dsp.html#structifx__mti__inst__f32">ifx_mti_inst_f32</a> *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>historical_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes MTI control structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>Pointer to configuration and history data previouly allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Exponential moving average parameter (0 highest historical influence, 1 lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of historical_data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">historical_data</td><td>Pointer to historical data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf3677b63229a5255d90140048b0edde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3677b63229a5255d90140048b0edde">&#9670;&nbsp;</a></span>ifx_mti_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_mti_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__sensor__dsp.html#structifx__mti__inst__f32">ifx_mti_inst_f32</a> *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32_t *&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(M)oving (T)arget (I)ndication </p>
<p>This algorithm work on exponential moving average to compute MTI. <br />
 As an input can be 1D/2D/complex number and computation will retain same only data size must be adequad for given type </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(index i = 0; i &lt; len; i++)</div><div class="line">{</div><div class="line">   h = historical_data[i]</div><div class="line">   x = in_data[i]</div><div class="line">   out_data[i] = x-h</div><div class="line">   historical_data[i] = (1 - alpha) * h + alpha * x</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inst</td><td>Pointer to configuration and history data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_data</td><td>Pointer to current data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Pointer to output data with movement indication (size must be identical as in_data) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab96c1f1ceab6c06d3b6c5d460bd0e791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab96c1f1ceab6c06d3b6c5d460bd0e791">&#9670;&nbsp;</a></span>ifx_peak_search_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ifx_peak_search_f32 </td>
          <td>(</td>
          <td class="paramtype">const float32_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>peak_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__sensor__dsp.html#structifx__peak__search__opts__f32__t">ifx_peak_search_opts_f32_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find peaks in array. </p>
<p>The function searches for peaks in an array. A peak is a point that is larger than its left and its right neighbor point. The pointer array together with the length len denote the left and right end of the search range.</p>
<p>The function searches for the max_peaks highest peaks and returns the number of peaks found. The function may find 0 peaks up to max_peaks peaks. The indices of the peaks are written to the array indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Pointer to array for peak search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of elements in array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peak_indices</td><td>Pointer to array that holds the indices of the peaks found. The array must hold at least max_peaks elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_peaks</td><td>Maximum number of peaks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Pointer to conditions structure for peaks </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of peaks found. The corresponding indices are written to peaks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05782d3800ac91410af581c86de274ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05782d3800ac91410af581c86de274ea">&#9670;&nbsp;</a></span>ifx_flip_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_flip_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip the array of float numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>Pointer to input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga973673fc0693751f4b82afa18df97c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973673fc0693751f4b82afa18df97c12">&#9670;&nbsp;</a></span>ifx_rotate_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ifx_rotate_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the array of float numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>Pointer to input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Number of positions to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="gaf6ff27583971a85ec04a57702b81e6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ff27583971a85ec04a57702b81e6e1">&#9670;&nbsp;</a></span>ifx_range_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float32_t ifx_range_resolution </td>
          <td>(</td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>bandwidth_hz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate range resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bandwidth_hz</td><td>Bandwidth in Hz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Range resolution </dd></dl>

</div>
</div>
<a id="ga28b6faae2c5b3c4fc20dd0a6f0b80d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b6faae2c5b3c4fc20dd0a6f0b80d8c">&#9670;&nbsp;</a></span>ifx_range_resolution_ex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float32_t ifx_range_resolution_ex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>sample_rate_hz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>freq_slope_hz_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate range resolution including number of samples, sample rate and frequency slope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Number of samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sample_rate_hz</td><td>Sample rate in Hz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq_slope_hz_s</td><td>Frequency slope in Hz/s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Range resolution </dd></dl>

</div>
</div>
<a id="ga0eb68635375f25ca2961b454c9914d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb68635375f25ca2961b454c9914d35">&#9670;&nbsp;</a></span>ifx_max_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float32_t ifx_max_range </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sample_rate_hz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>freq_slope_hz_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating max range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sample_rate_hz</td><td>Sample rate in Hz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq_slope_hz_s</td><td>Frequency slope in Hz/s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Max range </dd></dl>

</div>
</div>
<a id="ga804edab930fd07601db57fe99cb8f013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804edab930fd07601db57fe99cb8f013">&#9670;&nbsp;</a></span>ifx_doppler_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float32_t ifx_doppler_resolution </td>
          <td>(</td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>bandwidth_hz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>frame_time_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating Doppler resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bandwidth_hz</td><td>Bandwidth in Hz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_time_s</td><td>Frame time in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Doppler resolution </dd></dl>

</div>
</div>
<a id="gad507aa90ef143738733d5cddd2cc907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad507aa90ef143738733d5cddd2cc907a">&#9670;&nbsp;</a></span>ifx_max_doppler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float32_t ifx_max_doppler </td>
          <td>(</td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>bandwidth_hz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>chirp_time_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating Max Doppler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bandwidth_hz</td><td>Bandwidth in Hz </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chirp_time_s</td><td>Chirp time in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Max Doppler </dd></dl>

</div>
</div>
<a id="ga0d027a0c1558b06e5e7794a9b3b95055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d027a0c1558b06e5e7794a9b3b95055">&#9670;&nbsp;</a></span>ifx_arcsin_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status ifx_arcsin_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns arcus sinus of the given input, in radians. </p>
<p>The Implementation uses an identity and above arcus tangent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>input value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>output value in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status flag - ARM_MATH_SUCCESS on success and ARM_MATH_ARGUMENT_ERROR on error </dd></dl>

</div>
</div>
<a id="gaaa31f1c6bc68fe4b337e655072ca813c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa31f1c6bc68fe4b337e655072ca813c">&#9670;&nbsp;</a></span>ifx_angle_monopulse_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status ifx_angle_monopulse_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>rx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__sensor__dsp.html#ga8af72be35b8acbc9096afae448302b44">cfloat32_t</a> *&#160;</td>
          <td class="paramname"><em>rx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>antenna_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the angle of the direction of arrival of a monopulse Defines a method for calculating the angle of monopulse with given wavelength, spacing between two antennas and phase shifts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rx1</td><td>Pointer to input vector of antenna 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx2</td><td>Pointer to input vector of antenna 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Length of the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wavelength</td><td>Length of the wave (in units of meters) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">antenna_spacing</td><td>Distance between antennas (in units of meters) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>Pointer to output angle of the direction of monopulse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status flag - ARM_MATH_SUCCESS on success and ARM_MATH_ARGUMENT_ERROR on error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Sensor-DSP</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
